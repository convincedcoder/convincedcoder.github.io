<!DOCTYPE html>
<html>
  <head>
        <meta charset="utf-8" />
    <meta content='text/html; charset=utf-8' http-equiv='Content-Type'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0'>

    <!-- Begin Jekyll SEO tag v2.3.0 -->
<title>Java generics, wildcards and type erasure | Convinced Coder</title>
<meta property="og:title" content="Java generics, wildcards and type erasure" />
<meta name="author" content="Maarten Michiels" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="This post contains a high-level review of Java generics." />
<meta property="og:description" content="This post contains a high-level review of Java generics." />
<link rel="canonical" href="https://convincedcoder.com/2018/09/29/Java-generics-wildcards-type-erasure/" />
<meta property="og:url" content="https://convincedcoder.com/2018/09/29/Java-generics-wildcards-type-erasure/" />
<meta property="og:site_name" content="Convinced Coder" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-09-29T00:00:00+02:00" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:site" content="@convincedcoder" />
<meta name="twitter:creator" content="@convincedcoder" />
<script type="application/ld+json">
{"name":null,"description":"This post contains a high-level review of Java generics.","author":{"@type":"Person","name":"Maarten Michiels"},"@type":"BlogPosting","url":"https://convincedcoder.com/2018/09/29/Java-generics-wildcards-type-erasure/","publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"https://convincedcoder.com/images/convincedcoder.png"},"name":"Maarten Michiels"},"image":null,"headline":"Java generics, wildcards and type erasure","dateModified":"2018-09-29T00:00:00+02:00","datePublished":"2018-09-29T00:00:00+02:00","sameAs":null,"mainEntityOfPage":{"@type":"WebPage","@id":"https://convincedcoder.com/2018/09/29/Java-generics-wildcards-type-erasure/"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <!--[if lt IE 9]>
      <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <link rel="stylesheet" type="text/css" href="/style.css" />
		<link rel="alternate" type="application/rss+xml" title="Convinced Coder - A blog about general software development, Java and JavaScript" href="/feed.xml" />
		<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
		<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
		<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
		<link rel="manifest" href="/site.webmanifest">
		<meta name="msapplication-TileColor" content="#da532c">
		<meta name="theme-color" content="#ffffff">

    <!-- Created with Jekyll Now - http://github.com/barryclark/jekyll-now -->
  </head>

  <body>
	<!-- using Ryan Fait's sticky footer to stick the footer at the bottom of the page or content, whichever is lower -->
	
	<div class="sticky-footer-wrapper">
		<div class="wrapper-masthead">
		  <div class="container">
			<header class="masthead clearfix">
			  <a href="/" class="site-avatar"><img src="/images/convincedcoder.png" /></a>

			  <div class="site-info">
				<h1 class="site-name"><a href="/">Convinced Coder</a></h1>
				<p class="site-description">A blog about general software development, Java and JavaScript</p>
			  </div>

			  <nav>
				<a href="/">Blog</a>
				<a href="/about">About</a>
			  </nav>
			</header>
		  </div>
		</div>

		<div id="notice" class="container" style="background: #d28445; padding: 1em; border-radius: 0.5em; color: white;">
			<p>This blog is no longer being maintained. Most of the content has been migrated to the new website at <a href="https://learning-notes.mistermicheels.com" style="color: inherit; font-weight: bold;">learning-notes.mistermicheels.com</a>.</p>
			
			
				<p>New version of this post: <a href="https://learning-notes.mistermicheels.com/java/generics/" style="color: inherit; font-weight: bold;">Generics (Java)</a>.</p>
			
		</div>

		<div id="main" role="main" class="container">
		  <article class="post">
    <h1>Java generics, wildcards and type erasure</h1>
    
    <div class="date">
        2018-09-29
    </div>

    <div class=post-tags>
               
                 
            <a href="/tag/java" class="tag">java</a>
        
    </div>

    <div class="entry">
        <ul class="section-nav">
<li class="toc-entry toc-h2"><a href="#introducing-the-animal-and-dog-class">Introducing the Animal and Dog class</a></li>
<li class="toc-entry toc-h2"><a href="#generics-basics">Generics basics</a></li>
<li class="toc-entry toc-h2"><a href="#wildcards">Wildcards</a></li>
<li class="toc-entry toc-h2"><a href="#generics-in-the-java-virtual-machine">Generics in the Java Virtual Machine</a>
<ul>
<li class="toc-entry toc-h3"><a href="#type-erasure">Type erasure</a></li>
<li class="toc-entry toc-h3"><a href="#cast-insertion">Cast insertion</a></li>
<li class="toc-entry toc-h3"><a href="#bridge-methods">Bridge methods</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#the-class-class">The Class class</a></li>
<li class="toc-entry toc-h2"><a href="#generics-restrictions">Generics restrictions</a>
<ul>
<li class="toc-entry toc-h3"><a href="#type-arguments-cannot-be-primitives">Type arguments cannot be primitives</a></li>
<li class="toc-entry toc-h3"><a href="#at-runtime-all-types-are-raw">At runtime, all types are raw</a></li>
<li class="toc-entry toc-h3"><a href="#type-variables-cannot-be-instantiated">Type variables cannot be instantiated</a></li>
<li class="toc-entry toc-h3"><a href="#its-impossible-to-create-arrays-of-parameterized-types">Itâ€™s impossible to create arrays of parameterized types</a></li>
<li class="toc-entry toc-h3"><a href="#class-type-variables-are-not-valid-in-static-contexts">Class type variables are not valid in static contexts</a></li>
<li class="toc-entry toc-h3"><a href="#methods-may-not-clash-after-erasure">Methods may not clash after erasure</a></li>
<li class="toc-entry toc-h3"><a href="#exceptions-and-generics">Exceptions and generics</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#resources">Resources</a></li>
</ul><p>This post contains a high-level review of Java generics.</p>

<h2 id="introducing-the-animal-and-dog-class">
<a id="introducing-the-animal-and-dog-class" class="anchor" href="#introducing-the-animal-and-dog-class" aria-hidden="true"><span class="octicon octicon-link"></span></a>Introducing the Animal and Dog class</h2>

<p>This post will assume that we have two extremely simple classes, <code class="highlighter-rouge">Animal</code> and <code class="highlighter-rouge">Dog</code>, where the latter is a subclass of the former.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Animal</span> <span class="o">{</span>    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">makeSound</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"I'm an animal!"</span><span class="o">);</span>
    <span class="o">};</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Dog</span> <span class="kd">extends</span> <span class="n">Animal</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">makeSound</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Woof!"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="generics-basics">
<a id="generics-basics" class="anchor" href="#generics-basics" aria-hidden="true"><span class="octicon octicon-link"></span></a>Generics basics</h2>

<p>Java generics allow to define classes, interfaces and methods that work with different types. This happens by adding one or more type parameters.</p>

<p>A simple example of a generic interface is the List interface, which allows to specify the type of objects in the list.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">List</span><span class="o">&lt;</span><span class="n">Dog</span><span class="o">&gt;</span> <span class="n">dogList</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Dog</span><span class="o">&gt;();</span>
<span class="n">dogList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Dog</span><span class="o">());</span>
<span class="n">Dog</span> <span class="n">dog</span> <span class="o">=</span> <span class="n">dogList</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
<span class="n">dogList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Object</span><span class="o">());</span> <span class="c1">// compiler error</span>
</code></pre></div></div>

<p>The following is an example of a simple generic method.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="o">&lt;</span><span class="n">T</span> <span class="kd">extends</span> <span class="n">Animal</span><span class="o">&gt;</span> <span class="n">T</span> <span class="nf">getFirstAnimal</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">animals</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">animals</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>The above example also shows an example of a <em>type bound</em>: it allows <code class="highlighter-rouge">T</code> to be the <code class="highlighter-rouge">Animal</code> class or any of its subclasses. The same mechanism can be used for the type parameters of generic classes. Also note that the type parameter can be used inside the class.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AnimalWrapper</span><span class="o">&lt;</span><span class="n">T</span> <span class="kd">extends</span> <span class="n">Animal</span><span class="o">&gt;</span> <span class="o">{</span>    
    <span class="kd">private</span> <span class="n">T</span> <span class="n">wrappedAnimal</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">AnimalWrapper</span><span class="o">(</span><span class="n">T</span> <span class="n">wrappedAnimal</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">wrappedAnimal</span> <span class="o">=</span> <span class="n">wrappedAnimal</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="n">T</span> <span class="nf">getWrappedAnimal</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">wrappedAnimal</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="wildcards">
<a id="wildcards" class="anchor" href="#wildcards" aria-hidden="true"><span class="octicon octicon-link"></span></a>Wildcards</h2>

<p>Suppose that you need a list of <code class="highlighter-rouge">Animal</code>s for something and you define it as a <code class="highlighter-rouge">List&lt;Animal&gt;</code>. Can you just pass a <code class="highlighter-rouge">List&lt;Dog&gt;</code> in that case?</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">List</span><span class="o">&lt;</span><span class="n">Dog</span><span class="o">&gt;</span> <span class="n">dogList</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Dog</span><span class="o">&gt;();</span>
<span class="n">List</span><span class="o">&lt;</span><span class="n">Animal</span><span class="o">&gt;</span> <span class="n">animalList</span> <span class="o">=</span> <span class="n">dogList</span><span class="o">;</span> <span class="c1">// compiler error</span>
</code></pre></div></div>

<p>The reason why this fails is that a proper <code class="highlighter-rouge">List&lt;Animal&gt;</code> allows adding any <code class="highlighter-rouge">Animal</code>, while a <code class="highlighter-rouge">List&lt;Dog&gt;</code> should only allow adding <code class="highlighter-rouge">Dog</code>s. This means that the two types are not compatible. However, if we only care about the fact that our List contains some kind of <code class="highlighter-rouge">Animal</code>s, we can use type wildcards to define this.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">List</span><span class="o">&lt;</span><span class="n">Dog</span><span class="o">&gt;</span> <span class="n">dogList</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Dog</span><span class="o">&gt;();</span>
<span class="n">List</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">Animal</span><span class="o">&gt;</span> <span class="n">extendsAnimalList</span> <span class="o">=</span> <span class="n">dogList</span><span class="o">;</span> <span class="c1">// works</span>
</code></pre></div></div>

<p>If we define our List as a <code class="highlighter-rouge">List&lt;? extends Animal&gt;</code>, we specify that this is a List of <code class="highlighter-rouge">Animal</code> or one of its subclasses. This means that each element in the list is some kind of <code class="highlighter-rouge">Animal</code>. Note that this does not allow us to add any kind of <code class="highlighter-rouge">Animal</code> to the list, because as for all we know, the List might be a <code class="highlighter-rouge">List&lt;Dog&gt;</code> or a List of some other subclass of <code class="highlighter-rouge">Animal</code>.</p>

<p><code class="highlighter-rouge">? extends Animal</code> is called a <em>subtype wildcard</em>. Another type of wildcard is the <em>supertype wildcard</em>, for example <code class="highlighter-rouge">? super Dog</code>. If we define a <code class="highlighter-rouge">List&lt;? super Dog&gt;</code>, we know that we have a List of <code class="highlighter-rouge">Dog</code> or one of its supertypes. This means that, whatever the specific type of the List is, the list will always allow us to add a <code class="highlighter-rouge">Dog</code> object to it. However, we cannot make any assumptions regarding the types of objects in the list.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">List</span><span class="o">&lt;</span><span class="n">Dog</span><span class="o">&gt;</span> <span class="n">dogList</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Dog</span><span class="o">&gt;();</span>

<span class="n">List</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">Animal</span><span class="o">&gt;</span> <span class="n">extendsAnimalList</span> <span class="o">=</span> <span class="n">dogList</span><span class="o">;</span>
<span class="n">Animal</span> <span class="n">animal</span> <span class="o">=</span> <span class="n">extendsAnimalList</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span> <span class="c1">// works</span>
<span class="n">extendsAnimalList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Dog</span><span class="o">());</span> <span class="c1">// compiler error</span>

<span class="n">List</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">Dog</span><span class="o">&gt;</span> <span class="n">superDogList</span> <span class="o">=</span> <span class="n">dogList</span><span class="o">;</span>
<span class="n">Animal</span> <span class="n">animal2</span> <span class="o">=</span> <span class="n">superDogList</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span> <span class="c1">// compiler error</span>
<span class="n">superDogList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Dog</span><span class="o">());</span> <span class="c1">// works</span>
</code></pre></div></div>

<p>You could also use a wildcard without bounds when you are doing something very generic and donâ€™t care at all about the value of the type parameter.</p>

<h2 id="generics-in-the-java-virtual-machine">
<a id="generics-in-the-java-virtual-machine" class="anchor" href="#generics-in-the-java-virtual-machine" aria-hidden="true"><span class="octicon octicon-link"></span></a>Generics in the Java Virtual Machine</h2>

<p>In order to get a better understanding of how generics behave in Java, it helps to take a look at whatâ€™s happening under the hood.</p>

<h3 id="type-erasure">
<a id="type-erasure" class="anchor" href="#type-erasure" aria-hidden="true"><span class="octicon octicon-link"></span></a>Type erasure</h3>

<p>Java only added generics in version 1.5. Before that, instead of the generic <code class="highlighter-rouge">ArrayList&lt;T&gt;</code>, there was just the class <code class="highlighter-rouge">ArrayList</code>. When introducing generics, the Java team decided to maintain compatibility by actually erasing the generic type information at compile time, meaning that the byte code running in the Java Virtual Machine does not know anything about generics.</p>

<p>As an example, consider letâ€™s go back to our <code class="highlighter-rouge">AnimalWrapper</code> class.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AnimalWrapper</span><span class="o">&lt;</span><span class="n">T</span> <span class="kd">extends</span> <span class="n">Animal</span><span class="o">&gt;</span> <span class="o">{</span>    
    <span class="kd">private</span> <span class="n">T</span> <span class="n">wrappedAnimal</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">AnimalWrapper</span><span class="o">(</span><span class="n">T</span> <span class="n">wrappedAnimal</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">wrappedAnimal</span> <span class="o">=</span> <span class="n">wrappedAnimal</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="n">T</span> <span class="nf">getWrappedAnimal</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">wrappedAnimal</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This generic type is compiled into the follow <em>raw</em> type:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AnimalWrapper</span> <span class="o">{</span>    
    <span class="kd">private</span> <span class="n">Animal</span> <span class="n">wrappedAnimal</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">AnimalWrapper</span><span class="o">(</span><span class="n">Animal</span> <span class="n">wrappedAnimal</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">wrappedAnimal</span> <span class="o">=</span> <span class="n">wrappedAnimal</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="n">Animal</span> <span class="nf">getWrappedAnimal</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">wrappedAnimal</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Note that the wrappedAnimal has now become an <code class="highlighter-rouge">Animal</code> after type erasure. This makes sense: our type bound restricted the type T to be <code class="highlighter-rouge">Animal</code> or one of its subclasses. Type parameters without type bounds are erased to <code class="highlighter-rouge">Object</code>.</p>

<p>Before erasing the types, the compiler checks for errors involving generic types. For example, it will forbid wrapping an <code class="highlighter-rouge">Animal</code> in an <code class="highlighter-rouge">AnimalWrapper&lt;Dog&gt;</code>. This means that, although the types are erased later on, we know that the type variables are respected.</p>

<h3 id="cast-insertion">
<a id="cast-insertion" class="anchor" href="#cast-insertion" aria-hidden="true"><span class="octicon octicon-link"></span></a>Cast insertion</h3>

<p>Although the compiler checks for generic type mismatches, that this in itself is not always enough. An example is the following code:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">List</span><span class="o">&lt;</span><span class="n">Dog</span><span class="o">&gt;</span> <span class="n">dogList</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Dog</span><span class="o">&gt;();</span>        
<span class="n">List</span> <span class="n">rawList</span> <span class="o">=</span> <span class="n">dogList</span><span class="o">;</span>        
<span class="n">Animal</span> <span class="n">animal</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Animal</span><span class="o">();</span>
<span class="n">rawList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">animal</span><span class="o">);</span>
</code></pre></div></div>

<p>The code will generate compiler warnings, but if you ignore those, it can compile and run without issues. This is strange, because we now have an <code class="highlighter-rouge">Animal</code> object sitting in a <code class="highlighter-rouge">List&lt;Dog&gt;</code>. This is known as <em>heap pollution</em>. What about type safety?</p>

<p>Well, the way this is handled in Java is that the compiler inserts a cast whenever the code <em>reads</em> from an expression with erased type. This means that, while we can add the <code class="highlighter-rouge">Animal</code> to our <code class="highlighter-rouge">List&lt;Dog&gt;</code>, we will get a <code class="highlighter-rouge">ClassCastException</code> if we try to retrieve that <code class="highlighter-rouge">Animal</code> as a <code class="highlighter-rouge">Dog</code>.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">List</span><span class="o">&lt;</span><span class="n">Dog</span><span class="o">&gt;</span> <span class="n">dogList</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Dog</span><span class="o">&gt;();</span>  
<span class="n">List</span> <span class="n">rawList</span> <span class="o">=</span> <span class="n">dogList</span><span class="o">;</span>
<span class="n">Animal</span> <span class="n">animal</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Animal</span><span class="o">();</span>
<span class="n">rawList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">animal</span><span class="o">);</span>

<span class="n">Animal</span> <span class="n">retrievedAnimal</span> <span class="o">=</span> <span class="n">dogList</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span> <span class="c1">// works</span>
<span class="n">Dog</span> <span class="n">retrievedDog</span> <span class="o">=</span> <span class="n">dogList</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span> <span class="c1">// ClassCastException</span>
</code></pre></div></div>

<p>The behavior of the above code can be explained by looking at the compiled code, which is equivalent to the code below.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">List</span> <span class="n">dogList</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">();</span>  
<span class="n">List</span> <span class="n">rawList</span> <span class="o">=</span> <span class="n">dogList</span><span class="o">;</span>
<span class="n">Animal</span> <span class="n">animal</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Animal</span><span class="o">();</span>
<span class="n">rawList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">animal</span><span class="o">);</span>

<span class="c1">// note that the erased List.get() method returns an Object</span>
<span class="c1">// cast insertion generates casts based on target type</span>
<span class="n">Animal</span> <span class="n">retrievedAnimal</span> <span class="o">=</span> <span class="o">(</span><span class="n">Animal</span><span class="o">)</span> <span class="n">dogList</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span> <span class="c1">// works</span>
<span class="n">Dog</span> <span class="n">retrievedDog</span> <span class="o">=</span> <span class="o">(</span><span class="n">Dog</span><span class="o">)</span> <span class="n">dogList</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span> <span class="c1">// ClassCastException</span>
</code></pre></div></div>

<p>Note that we donâ€™t get an exception when we try to retrieve the <code class="highlighter-rouge">Animal</code> as an actual <code class="highlighter-rouge">Animal</code>. Also note that, when we get the <code class="highlighter-rouge">ClassCastException</code> on the last line, that does not help us to find the actual source of the problem (which is the code where we inserted an <code class="highlighter-rouge">Animal</code> inside a <code class="highlighter-rouge">List&lt;Dog&gt;</code>). When debugging such problem, it can be useful to use a checked view of the <code class="highlighter-rouge">List</code>. This checks the type of inserted objects as they are inserted.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">List</span><span class="o">&lt;</span><span class="n">Dog</span><span class="o">&gt;</span> <span class="n">dogList</span> <span class="o">=</span> 
    <span class="n">Collections</span><span class="o">.</span><span class="na">checkedList</span><span class="o">(</span><span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Dog</span><span class="o">&gt;(),</span> <span class="n">Dog</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

<span class="n">List</span> <span class="n">rawList</span> <span class="o">=</span> <span class="n">dogList</span><span class="o">;</span>
<span class="n">Animal</span> <span class="n">animal</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Animal</span><span class="o">();</span>
<span class="n">rawList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">animal</span><span class="o">);</span> <span class="c1">// ClassCastException</span>
</code></pre></div></div>

<p>Note the use of <code class="highlighter-rouge">Dog.class</code>, a <code class="highlighter-rouge">Class&lt;Dog&gt;</code> instance which is needed to know the actual value of the type parameter for the <code class="highlighter-rouge">List</code>. We will revisit the <code class="highlighter-rouge">Class&lt;T&gt;</code> class further down this post.</p>

<h3 id="bridge-methods">
<a id="bridge-methods" class="anchor" href="#bridge-methods" aria-hidden="true"><span class="octicon octicon-link"></span></a>Bridge methods</h3>

<p>In some cases, basic type erasure would lead to problems with method overriding. In order to prevent this, the Java compiler sometimes generates <em>bridge methods</em>. As an example, consider the class <code class="highlighter-rouge">GoodBoyList</code>.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">GoodBoyList</span> <span class="kd">extends</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Dog</span><span class="o">&gt;{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">add</span><span class="o">(</span><span class="n">Dog</span> <span class="n">dog</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">dog</span><span class="o">.</span><span class="na">pet</span><span class="o">():</span>
        <span class="k">return</span> <span class="kd">super</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">dog</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Now, letâ€™s say we use this class in the following way:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">GoodBoyList</span> <span class="n">goodBoyList</span> <span class="o">=</span> <span class="k">new</span> <span class="n">GoodBoyList</span><span class="o">();</span>
<span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Dog</span><span class="o">&gt;</span> <span class="n">dogList</span> <span class="o">=</span> <span class="n">goodBoyList</span><span class="o">;</span>
<span class="n">dogList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Dog</span><span class="o">());</span>
</code></pre></div></div>

<p>After erasure, the last line calls the erased <code class="highlighter-rouge">add(Object)</code> method on the <code class="highlighter-rouge">ArrayList</code> class. We would expect the <code class="highlighter-rouge">add(Dog)</code> method on <code class="highlighter-rouge">GoodBoyList</code> to override that method, but the problem is that the method signatures are different.</p>

<p>The compiler solves this by inserting a bridge method <code class="highlighter-rouge">add(Object)</code> into the <code class="highlighter-rouge">GoodBoyList</code> class. That method looks like this:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// overrides ArrayList.add(Object)</span>
<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">add</span><span class="o">(</span><span class="n">Object</span> <span class="n">dog</span><span class="o">)</span> <span class="o">{</span> 
    <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">add</span><span class="o">((</span><span class="n">Dog</span><span class="o">)</span> <span class="n">dog</span><span class="o">);</span> <span class="c1">// calls add(Dog) </span>
<span class="o">}</span>
</code></pre></div></div>

<p>After erasure, it is the bridge method that actually overrides the <code class="highlighter-rouge">ArrayList.add(Object)</code> method. It then calls the <code class="highlighter-rouge">GoodBoyList.add(Dog)</code> method.</p>

<p>Bridge methods can also be used when the return type varies. For example, imagine that our <code class="highlighter-rouge">GoodBoyList</code> also overrides the <code class="highlighter-rouge">get(int)</code> method.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">GoodBoyList</span> <span class="kd">extends</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Dog</span><span class="o">&gt;{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">Dog</span> <span class="nf">get</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Dog</span> <span class="n">dog</span> <span class="o">=</span> <span class="kd">super</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="n">dog</span><span class="o">.</span><span class="na">pet</span><span class="o">():</span>
        <span class="k">return</span> <span class="n">dog</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>After erasure, we need a bridge method to make overriding work here. This way, we get two <code class="highlighter-rouge">get</code> methods in <code class="highlighter-rouge">GoodBoyList</code>:</p>

<ul>
  <li>
<code class="highlighter-rouge">Dog get(int)</code>: this is the actual method as defined in <code class="highlighter-rouge">GoodBoyList</code>
</li>
  <li>
<code class="highlighter-rouge">Object get(int)</code>: this is a generated bridge method that overrides the <code class="highlighter-rouge">Object get(int)</code> method in <code class="highlighter-rouge">ArrayList</code>.</li>
</ul>

<p>This may seem strange, because the compiler would never allow you to write a class with two methods with the same name taking the same number and type of arguments. However, inside the Java Virtual Machine, a method is defined by its name, the number and types of its arguments <em>and</em> by its return type. This is why the bridge method is needed, and also why it is allowed to exist.</p>

<p>The compiler takes care of the generation of bridge methods, so in principle you donâ€™t have to worry about them. However, they may show up in stack traces or explain why the compiler complains about certain pieces of code.</p>

<h2 id="the-class-class">
<a id="the-class-class" class="anchor" href="#the-class-class" aria-hidden="true"><span class="octicon octicon-link"></span></a>The Class class</h2>

<p>The Java language has a <code class="highlighter-rouge">Class&lt;T&gt;</code> class. A <code class="highlighter-rouge">Class&lt;T&gt;</code> object represent the class <code class="highlighter-rouge">T</code>. This class object can directly be obtained from the class <code class="highlighter-rouge">T</code>. It is also possible to to get a <code class="highlighter-rouge">Class</code> object from an instance of a class, but in that case you are getting the actual run-time type of that instance, which may be a subclass of its compile-time type.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Class</span><span class="o">&lt;</span><span class="n">Dog</span><span class="o">&gt;</span> <span class="n">test</span> <span class="o">=</span> <span class="n">Dog</span><span class="o">.</span><span class="na">class</span><span class="o">;</span> <span class="c1">// ok</span>
<span class="n">Class</span><span class="o">&lt;</span><span class="n">Dog</span><span class="o">&gt;</span> <span class="n">test2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Dog</span><span class="o">().</span><span class="na">getClass</span><span class="o">();</span> <span class="c1">// error</span>
<span class="n">Class</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">Dog</span><span class="o">&gt;</span> <span class="n">test3</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Dog</span><span class="o">().</span><span class="na">getClass</span><span class="o">();</span> <span class="c1">// ok</span>
</code></pre></div></div>

<p>You can use the <code class="highlighter-rouge">Class</code> class to get more information regarding the value of a type variable at run-time (so after type erasure). As an example, the below code for the <code class="highlighter-rouge">Test</code> class forces you to pass a <code class="highlighter-rouge">Class&lt;T&gt;</code> object where <code class="highlighter-rouge">T</code> is exactly value of the type variable of class <code class="highlighter-rouge">Test</code>. Even though the generic type information is erased during compilation, you can still determine the type of objects you are dealing with by looking at the <code class="highlighter-rouge">Class</code> instance.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>    
    <span class="n">Test</span><span class="o">(</span><span class="n">T</span> <span class="n">object</span><span class="o">,</span> <span class="n">Class</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">objectClass</span><span class="o">)</span> <span class="o">{}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>            
        <span class="n">Dog</span> <span class="n">dog</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Dog</span><span class="o">();</span>
        <span class="k">new</span> <span class="n">Test</span><span class="o">&lt;</span><span class="n">Animal</span><span class="o">&gt;(</span><span class="n">dog</span><span class="o">,</span> <span class="n">Animal</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Note that the <code class="highlighter-rouge">Class</code> object we receive is the exact class of the type parameterâ€™s value, but it is not necessarily the exact class of the object that we receive. That object may be an instance of a subclass.</p>

<p>The <code class="highlighter-rouge">Class&lt;T&gt;</code> object is also very useful when using reflection. For example, it can help you access the constructor(s) for the class.</p>

<h2 id="generics-restrictions">
<a id="generics-restrictions" class="anchor" href="#generics-restrictions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Generics restrictions</h2>

<h3 id="type-arguments-cannot-be-primitives">
<a id="type-arguments-cannot-be-primitives" class="anchor" href="#type-arguments-cannot-be-primitives" aria-hidden="true"><span class="octicon octicon-link"></span></a>Type arguments cannot be primitives</h3>

<p>A type parameter must always be <code class="highlighter-rouge">Object</code> or a subclass of <code class="highlighter-rouge">Object</code>. This means that, for example, it is not possible to define an <code class="highlighter-rouge">ArrayList&lt;int&gt;</code>.</p>

<h3 id="at-runtime-all-types-are-raw">
<a id="at-runtime-all-types-are-raw" class="anchor" href="#at-runtime-all-types-are-raw" aria-hidden="true"><span class="octicon octicon-link"></span></a>At runtime, all types are raw</h3>

<p>Type erasure means that, at runtime, all types are raw. Therefore, something like <code class="highlighter-rouge">if (object instanceof ArrayList&lt;Dog&gt;)</code> will not compile because this check is impossible to execute at runtime.</p>

<p>The <code class="highlighter-rouge">Class</code> instances that you get are also always raw types. There is no <code class="highlighter-rouge">ArrayList&lt;Dog&gt;.class</code>, only <code class="highlighter-rouge">ArrayList.class</code>.</p>

<h3 id="type-variables-cannot-be-instantiated">
<a id="type-variables-cannot-be-instantiated" class="anchor" href="#type-variables-cannot-be-instantiated" aria-hidden="true"><span class="octicon octicon-link"></span></a>Type variables cannot be instantiated</h3>

<p>If you have a type variable <code class="highlighter-rouge">T</code>, you cannot do <code class="highlighter-rouge">new T(...)</code> or <code class="highlighter-rouge">new T[...]</code> (array). This is forbidden because of type erasure (you would be instantiating the erased value for <code class="highlighter-rouge">T</code>, not <code class="highlighter-rouge">T</code> itself).</p>

<p>If you want to construct objects of type <code class="highlighter-rouge">T</code> or arrays of type <code class="highlighter-rouge">T</code> inside a generic method, you will have to ask the caller for the right object or array constructor or for a <code class="highlighter-rouge">Class</code> object.</p>

<p>Note that, while you cannot instantiate an array of type <code class="highlighter-rouge">T</code>, you can easily create an <code class="highlighter-rouge">ArrayList&lt;T&gt;</code>. This is because <code class="highlighter-rouge">ArrayList</code> is a generic type itself, while in order to create an array of type <code class="highlighter-rouge">T</code> we would need the exact type <code class="highlighter-rouge">T</code> at runtime.</p>

<h3 id="its-impossible-to-create-arrays-of-parameterized-types">
<a id="its-impossible-to-create-arrays-of-parameterized-types" class="anchor" href="#its-impossible-to-create-arrays-of-parameterized-types" aria-hidden="true"><span class="octicon octicon-link"></span></a>Itâ€™s impossible to create arrays of parameterized types</h3>

<p>Although you can declare arrays of a parameterized type (e.g. <code class="highlighter-rouge">AnimalWrapper&lt;Dog&gt;[]</code>), it is not possible to instantiate an array of that type. This is because, after erasure, we would just get an <code class="highlighter-rouge">AnimalWrapper[]</code> array that allows any kind of <code class="highlighter-rouge">AnimalWrapper</code> without throwing an <code class="highlighter-rouge">ArrayStoreException</code>. If that is what you want, you can create an <code class="highlighter-rouge">AnimalWrapper[]</code> and then cast it to <code class="highlighter-rouge">AnimalWrapper&lt;Dog&gt;[]</code> (this will generate compiler warnings though).</p>

<p>The simplest solution is often to just create an <code class="highlighter-rouge">ArrayList&lt;AnimalWrapper&lt;Dog&gt;&gt;</code> instead.</p>

<h3 id="class-type-variables-are-not-valid-in-static-contexts">
<a id="class-type-variables-are-not-valid-in-static-contexts" class="anchor" href="#class-type-variables-are-not-valid-in-static-contexts" aria-hidden="true"><span class="octicon octicon-link"></span></a>Class type variables are not valid in static contexts</h3>

<p>Type variables defined at the level of the class cannot be used in static contexts (static variables and static methods). For example, if you have a class with type parameter <code class="highlighter-rouge">T</code>, you cannot have a static variable of type <code class="highlighter-rouge">T</code>. This makes sense: you can use a class multiple times with different values for <code class="highlighter-rouge">T</code> but a static variable only exists once (on the raw type), so itâ€™s impossible to have a static variable with the exact type <code class="highlighter-rouge">T</code> for each of those values.</p>

<p>Remember that you can still use type variables in static contexts if they are not defined at the level of the class. For example, you can have a static method parameterized with type <code class="highlighter-rouge">T</code> if that type parameter is declared at the level of the method.</p>

<h3 id="methods-may-not-clash-after-erasure">
<a id="methods-may-not-clash-after-erasure" class="anchor" href="#methods-may-not-clash-after-erasure" aria-hidden="true"><span class="octicon octicon-link"></span></a>Methods may not clash after erasure</h3>

<p>You are not allowed to declare methods that would clash after erasure (meaning that, after erasure, there would be two methods with the same signature).</p>

<p>Note that this includes bridge methods! If you get a compiler error about methods clashing after erasure, itâ€™s possible that the clash is generated by the bridge methods generated by the compiler. This is why itâ€™s important to have some understanding of what these bridge methods are.</p>

<h3 id="exceptions-and-generics">
<a id="exceptions-and-generics" class="anchor" href="#exceptions-and-generics" aria-hidden="true"><span class="octicon octicon-link"></span></a>Exceptions and generics</h3>

<p>Itâ€™s not possible to throw objects of a generic class. This makes sense, because catching instances of a generic class with a specific type parameter would require information that is not available at runtime.</p>

<p>However, it is allowed to have a type variable in your <code class="highlighter-rouge">throws</code> declaration, as this is checked by the compiler.</p>

<h2 id="resources">
<a id="resources" class="anchor" href="#resources" aria-hidden="true"><span class="octicon octicon-link"></span></a>Resources</h2>

<ul>
  <li>Core Java SE 9 for the Impatient (book by Cay S. Horstmann)</li>
</ul>

    </div>

    
</article>

		</div>
		
		<div class="sticky-footer-push"></div>
	</div>

    <div class="wrapper-footer sticky-footer-footer">
      <div class="container">
        <footer class="footer">
          



<a href="https://github.com/convincedcoder/convincedcoder.github.io-source"><i class="svg-icon github"></i></a>




<a href="https://www.twitter.com/convincedcoder"><i class="svg-icon twitter"></i></a>



        </footer>
      </div>
    </div>

		
	<!-- Google Analytics -->
	<script>
		(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
		m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
		})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

		ga('create', 'UA-130247825-1', 'auto');
		ga('send', 'pageview', {
		  'page': '/2018/09/29/Java-generics-wildcards-type-erasure/',
		  'title': 'Java generics, wildcards and type erasure'
		});
	</script>
	<!-- End Google Analytics -->


		
		<script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script>
<script>addBackToTop({
  diameter: 50,
  backgroundColor: '#2f2f2f',
  textColor: '#fff'
})</script> 
  </body>
</html>
